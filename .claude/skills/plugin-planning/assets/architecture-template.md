# DSP Architecture: [PluginName]

**CRITICAL CONTRACT:** This specification is immutable during Stages 2-5 implementation. Stage 1 Planning cannot proceed without this file. Stage 4 (DSP) implements this exact architecture.

**Generated by:** Stage 0 Research
**Referenced by:** Stage 1 (Planning), Stage 4 (DSP Implementation)
**Purpose:** DSP specification defining processing components, signal flow, and JUCE module usage

---

## Core Components

[For each DSP component, create a subsection with this structure:]

### [Component Name]
- **JUCE Class:** `juce::dsp::ClassName` or "Custom implementation (description)"
- **Purpose:** [What this component does]
- **Parameters Affected:** [List parameter IDs that control this component]
- **Configuration:**
  - [Specific settings, ranges, formulas]
  - [Initialization parameters]
  - [Any special handling]

**Example:**
```markdown
### Reverb Engine
- **JUCE Class:** `juce::dsp::Reverb`
- **Purpose:** Generate plate-style reverb with controllable size and decay
- **Parameters Affected:** SIZE, DECAY
- **Configuration:**
  - SIZE (0-100%) maps to roomSize parameter (0.0-1.0)
  - DECAY (0.1-10s) maps to combined roomSize + damping
  - Width fixed at 1.0 (full stereo)
  - freezeMode disabled
```

---

## Processing Chain

[ASCII diagram showing signal flow and parameter connections]

**Example:**
```
Input
  ↓
Dry/Wet Mixer (capture dry) ← MIX parameter
  ↓
Plate Reverb ← SIZE, DECAY parameters
  ↓
Modulation Delay ← AGE parameter
  ↓
Tape Saturation ← DRIVE parameter
  ↓
Filter ← TONE parameter
  ↓
Dry/Wet Mixer (blend) ← MIX parameter
  ↓
Output
```

**Routing notes:**
- [Describe any conditional routing]
- [Parallel processing paths]
- [Feedback loops]
- [Sidechain inputs]

---

## Parameter Mapping

[Table mapping every parameter ID to DSP component and usage]

| Parameter ID | Type | Range | DSP Component | Usage |
|-------------|------|-------|---------------|-------|
| SIZE | Float | 0-100% | Reverb Engine | Maps to roomSize (0.0-1.0) |
| DECAY | Float | 0.1-10s | Reverb Engine | Maps to damping (inverse) |
| AGE | Float | 0-100% | Modulation Delay | Modulation depth (±20%) |
| DRIVE | Float | 0-100% | Tape Saturation | Gain factor (1.0-10.0) |
| TONE | Float | -100 to +100 | Filter | LP (negative) / HP (positive) |
| MIX | Float | 0-100% | Dry/Wet Mixer | Wet proportion (0.0-1.0) |
| MOD_MODE | Bool | 0/1 | Routing | Wet-only (0) or Wet+Dry (1) |

---

## Algorithm Details

[For each algorithm/component, describe the implementation approach]

### [Component Name]

**Algorithm:** [Mathematical description or processing approach]

**Implementation notes:**
- [Key formulas]
- [Coefficient calculation]
- [Interpolation method]
- [Edge case handling]

**Example:**
```markdown
### Tape Saturation

**Algorithm:** Hyperbolic tangent waveshaping

**Implementation notes:**
- Transfer function: `output = tanh(gain * input)`
- Gain curve: Linear 1.0-10.0 based on DRIVE (0-100%)
- Formula: `gain = 1.0 + (driveValue * 9.0)` where driveValue is 0.0-1.0
- No oversampling (reverb already has high-frequency rolloff)
- Apply per-sample in processBlock loop
```

---

## Special Considerations

### Thread Safety
- [Parameter access patterns - atomic reads?]
- [Lock-free update mechanisms]
- [Buffer ownership]

**Example:**
```markdown
- All parameter reads use atomic getRawParameterValue()->load()
- Filter coefficient updates happen in audio thread (no allocations)
- LFO phase state is per-channel (no shared state between channels)
```

### Performance
- [Estimated CPU usage per component]
- [Hot paths and optimization opportunities]
- [Buffer size sensitivity]

**Example:**
```markdown
- Reverb: ~30% CPU (most expensive component)
- Delay line interpolation: ~10% CPU
- Total estimated: ~50% single core at 48kHz
```

### Denormal Protection
- [How denormals are handled]
- [Which components need protection]

**Example:**
```markdown
- Use juce::ScopedNoDenormals in processBlock()
- All JUCE DSP components handle denormals internally
- Custom LFO uses phase wrapping to avoid denormals
```

### Sample Rate Handling
- [Sample rate dependent calculations]
- [Coefficient recalculation on rate change]
- [prepareToPlay requirements]

**Example:**
```markdown
- Reverb reinitialized in prepareToPlay() with new sample rate
- Delay line buffer sized for 200ms at maximum expected rate (192kHz)
- LFO phase increment: `(frequency * 2π) / sampleRate`
```

### Latency
- [Processing latency sources]
- [Host compensation requirements]

**Example:**
```markdown
- Base delay: 50ms (2400 samples at 48kHz)
- Reverb: 20-50ms internal latency
- Report total via getLatencySamples() for host compensation
```

---

## Research References

### Professional Plugins
[List 3-5 industry plugins researched, with observations]

**Example:**
```markdown
1. **Valhalla VintageVerb**
   - Classic plate reverb algorithms
   - Parameter range: Decay 0.1-20s typical
   - Observed: Heavy damping at short decay times

2. **FabFilter Pro-R**
   - Modern algorithmic reverb
   - Real-time spectrum display for feedback
   - Noted: Decay time affects both roomSize and damping parameters

3. **UAD EMT 140 Plate**
   - Hardware plate reverb emulation
   - Typical settings: Decay 1-5s for musical material
   - Warmth control similar to saturation drive
```

### JUCE Documentation
[Document JUCE classes researched and key findings]

**Example:**
```markdown
- **juce::dsp::Reverb**: Built-in reverb with roomSize, damping, width, freeze
- **juce::dsp::DelayLine**: Variable delay with multiple interpolation types
  - Lagrange3rd recommended for pitch modulation (smooth, low artifacts)
- **juce::dsp::IIR::Filter**: Biquad filter with coefficient helpers
- **juce::dsp::DryWetMixer**: Handles latency-compensated dry/wet mixing
```

### Technical Resources
[Any academic papers, DSP books, tutorials referenced]

**Example:**
```markdown
- DAFX (Digital Audio Effects) - Reverb chapter for algorithm understanding
- Designing Audio Effect Plugins in C++ (Will Pirkle) - Filter design patterns
- freeverb algorithm - Open-source reference for understanding Reverb parameters
```

---

## Notes

[Any additional context, decisions made during research, open questions]

**Example:**
```markdown
- Chose Lagrange3rd interpolation over Linear for smoother pitch modulation
- Decided against oversampling for saturation (reverb already band-limits)
- MOD_MODE routing decision: wet-only vs wet+dry based on creative brief
- Filter bypass zone (±0.5%) prevents clicking when sweeping through center
```
