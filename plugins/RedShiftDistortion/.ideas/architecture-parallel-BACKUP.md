# DSP Architecture: RedShiftDistortion

**CRITICAL CONTRACT:** This specification is immutable during Stages 1-4 implementation. Stage 1 Planning cannot proceed without this file. Stage 3 (DSP) implements this exact architecture.

**Generated by:** Stage 0 Research (2026-02-05)
**Referenced by:** Stage 1 (Planning), Stage 3 (DSP Implementation)
**Purpose:** DSP specification defining processing components, signal flow, and JUCE module usage

---

## Core Components

### Parallel Signal Router
- **JUCE Class:** Custom implementation using two independent signal paths
- **Purpose:** Split input audio into two independent processing chains (delay path and distortion path) before final mixing
- **Parameters Affected:** None directly (routing is fixed architecture)
- **Configuration:**
  - Input signal duplicated to both paths at processBlock() entry
  - Each path processes independently without interaction
  - Final output is sum of both paths scaled by their respective level controls
  - No cross-talk between paths (true parallel processing)

### Tube Saturation Engine (Distortion Path)
- **JUCE Class:** Custom implementation using std::tanh() waveshaping
- **Purpose:** Apply warm harmonic distortion characteristic of tube amplifiers to distortion path signal
- **Parameters Affected:** saturation (-12dB to +24dB)
- **Configuration:**
  - Saturation range: -12dB to +24dB maps to gain factor 0.25x to 15.85x
  - Formula: `gain = std::pow(10.0f, saturationDb / 20.0f)` (dB to linear gain)
  - Transfer function: `output = std::tanh(gain * input)`
  - Generates primarily 2nd and 3rd order harmonics (warm tube character)
  - Applied per-sample in processBlock loop
  - No oversampling (saturation is moderate, aliasing minimal)

### Pitch Shifter (Delay Path - Doppler Effect)
- **JUCE Class:** Custom implementation using granular synthesis or JUCE phase vocoder (if available)
- **Purpose:** Shift pitch up or down to create doppler effect (receding/approaching sound)
- **Parameters Affected:** dopplerShift (-50% to +50%), pitchEnable (on/off)
- **Configuration:**
  - Pitch shift range: ±1 octave (±12 semitones)
  - dopplerShift maps to semitones: -50% → -12 semitones, +50% → +12 semitones
  - Formula: `semitones = (dopplerShift / 100.0f) * 12.0f`
  - pitchEnable toggles pitch shifting on/off (when off, only time stretching applies)
  - Implementation approach: Granular synthesis with pitch-shifted grain playback
  - Grain size: 50-100ms, overlap factor: 4x (75% overlap)
  - Window function: Hann window for smooth grain boundaries

**Granular Synthesis Implementation:**
- Grain buffer size: 100ms at 48kHz = 4800 samples
- Overlap: 75% (4 simultaneous grains)
- Grain advance: 25ms per grain spawn
- Pitch shift via grain playback rate: `rate = std::pow(2.0f, semitones / 12.0f)`
- Grain envelope: Hann window (smooth attack/release)

### Time Stretcher (Delay Path - Doppler Effect)
- **JUCE Class:** Custom implementation integrated with pitch shifter
- **Purpose:** Change audio playback speed without affecting pitch (when pitchEnable is off)
- **Parameters Affected:** dopplerShift (-50% to +50%), pitchEnable (on/off)
- **Configuration:**
  - When pitchEnable = OFF: Apply time stretching only (speed changes without pitch)
  - Time stretch range: 0.5x to 2.0x speed
  - Formula: `timeStretchFactor = 1.0f + (dopplerShift / 100.0f)` (±50% stretch)
  - Implemented via same granular engine with constant pitch, variable grain advance rate
  - Grain advance rate modulation: `grainAdvance = baseAdvance * timeStretchFactor`

### Delay Line (Delay Path - Core Delay)
- **JUCE Class:** `juce::dsp::DelayLine<float, juce::dsp::DelayLineInterpolationTypes::Lagrange3rd>`
- **Purpose:** Provide tempo-synced or free-time delay with smooth delay time modulation
- **Parameters Affected:** delayTime (1/16 to 8 bars or 0-16000ms), tempoSync (on/off)
- **Configuration:**
  - Tempo-synced mode: Musical subdivisions (1/16, 1/8, 1/4, 1/2, 1, 2, 4, 8 bars)
  - Free time mode: 0-16000ms (0-16 seconds)
  - Maximum delay buffer: 20 seconds at 192kHz = 3,840,000 samples
  - Interpolation: Lagrange3rd (smooth, low artifacts for doppler modulation)
  - Delay time modulation: Applied via doppler shift (varies delay time for pitch artifacts)

**Tempo Sync Implementation:**
- Get host BPM via `getPlayHead()->getPosition()->getBpm()`
- Default BPM: 120.0 (if host doesn't provide tempo)
- Note division to milliseconds: `ms = (60000.0 / bpm) * beats`
  - 1/16 note: 0.25 beats
  - 1/8 note: 0.5 beats
  - 1/4 note: 1.0 beats
  - 1/2 note: 2.0 beats
  - 1 bar: 4.0 beats
  - 2 bars: 8.0 beats
  - 4 bars: 16.0 beats
  - 8 bars: 32.0 beats
- Quantization: Snap delayTime parameter to nearest note division when tempoSync enabled

### Delay Time Modulator (Delay Path - Doppler Simulation)
- **JUCE Class:** Custom implementation (LFO modulating delay time)
- **Purpose:** Modulate delay line length to create natural pitch artifacts (doppler effect via tape flutter)
- **Parameters Affected:** dopplerShift (-50% to +50%)
- **Configuration:**
  - Modulation depth: Scaled by dopplerShift magnitude (0-50% → 0-10% delay time variation)
  - LFO frequency: 0.5Hz to 2.0Hz (slow tape flutter characteristics)
  - LFO waveform: Sine wave (smooth, natural modulation)
  - Applied continuously to delay line read position
  - Creates natural pitch bend artifacts characteristic of tape speed variation

### Output Mixer (3-Stage Level Control)
- **JUCE Class:** Custom implementation (simple gain staging)
- **Purpose:** Control relative levels of delay path, distortion path, and final output
- **Parameters Affected:** delayLevel (-60dB to 0dB), distortionLevel (-60dB to 0dB), masterOutput (-60dB to +12dB)
- **Configuration:**
  - delayLevel: Scales delay path output before summing (-60dB to 0dB)
  - distortionLevel: Scales distortion path output before summing (-60dB to 0dB)
  - masterOutput: Scales final summed output (-60dB to +12dB)
  - dB to linear conversion: `gain = std::pow(10.0f, db / 20.0f)`
  - Mixing formula: `output = (delayPath * delayGain) + (distortionPath * distortionGain) * masterGain`

---

## Processing Chain

```
Input (Stereo)
  ↓
  ├──────────────────────────────────────────────────────────┐
  │                                                            │
  │  DELAY PATH                         DISTORTION PATH       │
  │                                                            │
  │  ↓                                  ↓                     │
  │  Delay Line ← delayTime             Tube Saturation       │
  │  (tempo-sync or free)               ← saturation          │
  │  ↓                                  ↓                     │
  │  Delay Time Modulator               Output × distortionLevel
  │  ← dopplerShift (LFO)               ↓                     │
  │  ↓                                  │                     │
  │  Pitch Shifter                      │                     │
  │  ← dopplerShift, pitchEnable        │                     │
  │  (granular synthesis)               │                     │
  │  ↓                                  │                     │
  │  Time Stretcher                     │                     │
  │  ← dopplerShift (when pitch off)    │                     │
  │  ↓                                  │                     │
  │  Output × delayLevel                │                     │
  │  ↓                                  │                     │
  └──────────────────────────────┬─────┘                     │
                                  ↓                            │
                                  Sum (Parallel Mix)           │
                                  ↓                            │
                                  Master Output Gain           │
                                  ← masterOutput               │
                                  ↓                            │
                                  Output (Stereo)              │
```

**Routing notes:**
- No interaction between delay and distortion paths (true parallel)
- Delay path processes first (arbitrary order, no dependency)
- Distortion path processes second (arbitrary order, no dependency)
- Both paths sum at mixer stage with independent level controls
- Master output gain applied to final summed signal

---

## System Architecture

### Tempo Synchronization System

**Purpose:** Lock delay time to host tempo with musical subdivisions

**JUCE classes:**
- `AudioPlayHead::getPosition()` - Get host playback position info
- `PositionInfo::getBpm()` - Extract BPM from host

**Implementation:**
1. Query host BPM in processBlock() via `getPlayHead()->getPosition()->getBpm()`
2. Default to 120 BPM if host doesn't provide tempo
3. Clamp BPM to valid range: 20-300 BPM
4. Convert note divisions to milliseconds: `ms = (60000 / bpm) * beats`
5. Map delayTime parameter to note divisions when tempoSync enabled:
   - 1/16 note (0.25 beats)
   - 1/8 note (0.5 beats)
   - 1/4 note (1.0 beats)
   - 1/2 note (2.0 beats)
   - 1 bar (4.0 beats)
   - 2 bars (8.0 beats)
   - 4 bars (16.0 beats)
   - 8 bars (32.0 beats)

**Free time mode:**
- When tempoSync = OFF, delayTime parameter directly controls milliseconds (0-16000ms)
- No BPM query needed (saves CPU)

**Reference:** AngelGrain tempo sync implementation (lines 170-190 in PluginProcessor.cpp)

### State Persistence

**What state is saved:**
- APVTS parameters: saturation, dopplerShift, pitchEnable, delayTime, tempoSync, delayLevel, distortionLevel, masterOutput (automatic)
- No custom state needed (all state is parameter-based)

**Serialization format:**
- APVTS: Automatic via `AudioProcessorValueTreeState`
- XML via ValueTree (JUCE standard)

**JUCE classes:**
- `juce::AudioProcessorValueTreeState` - Parameter persistence (automatic)
- `juce::ValueTree` - State tree serialization

**Save/restore methods:**
- `getStateInformation(MemoryBlock& destData)` - Serialize APVTS state to XML
- `setStateInformation(const void* data, int sizeInBytes)` - Deserialize APVTS state from XML

**Restore behavior:**
- All parameters restored to saved values automatically by APVTS
- No validation needed (parameters have defined ranges)
- No version migration needed (v1.0.0 initial release)

---

## Parameter Mapping

| Parameter ID | Type | Range | DSP Component | Usage |
|-------------|------|-------|---------------|-------|
| saturation | Float | -12.0 to 24.0 dB | Tube Saturation | Gain factor (0.25x to 15.85x) |
| dopplerShift | Float | -50.0 to 50.0 % | Pitch Shifter, Time Stretcher, Delay Modulator | Pitch shift (±12 semitones), time stretch (±50%), delay modulation depth |
| pitchEnable | Bool | On/Off | Pitch Shifter | Enable/disable pitch shifting (keeps time stretch when off) |
| delayTime | Float | 1/16 to 8 bars OR 0-16000 ms | Delay Line | Delay length (tempo-synced or free time) |
| tempoSync | Bool | On/Off | Tempo Sync System | Lock to host tempo (musical) or free time (milliseconds) |
| delayLevel | Float | -60.0 to 0.0 dB | Output Mixer | Volume of delay path |
| distortionLevel | Float | -60.0 to 0.0 dB | Output Mixer | Volume of distortion path |
| masterOutput | Float | -60.0 to 12.0 dB | Output Mixer | Final output gain |

---

## Algorithm Details

### Tube Saturation

**Algorithm:** Hyperbolic tangent waveshaping with adjustable drive

**Implementation notes:**
- Transfer function: `output = std::tanh(gain * input)`
- Gain curve: Exponential mapping from dB to linear gain
  - Formula: `gain = std::pow(10.0f, saturationDb / 20.0f)`
  - -12dB → 0.25x gain (clean, subtle saturation)
  - 0dB → 1.0x gain (unity gain, mild saturation)
  - +12dB → 3.98x gain (moderate tube warmth)
  - +24dB → 15.85x gain (heavy tube distortion)
- Saturation characteristics:
  - tanh() produces primarily 2nd and 3rd order harmonics (warm, musical)
  - Soft clipping (smooth transition to saturation region)
  - Asymmetric distortion (mimics tube behavior)
- No oversampling needed (moderate saturation, minimal aliasing)
- Applied per-sample in processBlock loop

### Granular Pitch Shifting

**Algorithm:** Granular synthesis with pitch-shifted grain playback

**Implementation notes:**
- Grain size: 100ms at 48kHz = 4800 samples (fixed grain buffer)
- Grain overlap: 75% (4 simultaneous grains for smooth output)
- Grain advance: 25ms per grain spawn (grain size × 0.25)
- Window function: Hann window (smooth attack/release, minimizes clicks)
  - Formula: `window[i] = 0.5 * (1.0 - std::cos(2π * i / grainSize))`
- Pitch shift via grain playback rate:
  - Formula: `rate = std::pow(2.0f, semitones / 12.0f)`
  - -12 semitones (dopplerShift = -50%) → rate = 0.5 (one octave down)
  - 0 semitones (dopplerShift = 0%) → rate = 1.0 (no pitch shift)
  - +12 semitones (dopplerShift = +50%) → rate = 2.0 (one octave up)
- Grain playback:
  - Read from delay line output at variable rate
  - Apply Hann window to grain
  - Overlap-add 4 grains for continuous output
- Artifact mitigation:
  - Large grain size (100ms) reduces graininess
  - High overlap (75%) smooths transitions
  - Hann window eliminates clicks

### Time Stretching (Pitch Disabled)

**Algorithm:** Granular synthesis with constant pitch, variable grain advance

**Implementation notes:**
- Same granular engine as pitch shifter, but with fixed playback rate
- Grain playback rate: 1.0 (no pitch shift)
- Grain advance rate varies with dopplerShift:
  - Formula: `grainAdvance = baseAdvance * (1.0f + dopplerShift / 100.0f)`
  - dopplerShift = -50% → grainAdvance = 0.5x (slow motion, half speed)
  - dopplerShift = 0% → grainAdvance = 1.0x (normal speed)
  - dopplerShift = +50% → grainAdvance = 1.5x (fast forward, 1.5x speed)
- Time stretching without pitch:
  - Faster grain advance = faster playback without pitch change
  - Slower grain advance = slower playback without pitch change
- Output duration changes (not pitch):
  - -50% doppler → 200% duration (half speed)
  - +50% doppler → 67% duration (1.5x speed)

### Delay Time Modulation (Doppler Simulation)

**Algorithm:** LFO-driven delay line length modulation (tape flutter simulation)

**Implementation notes:**
- LFO waveform: Sine wave (smooth, natural modulation)
- LFO frequency: 1.0Hz (slow tape flutter, adjustable via dopplerShift magnitude)
  - Formula: `lfoFreq = 0.5f + (std::abs(dopplerShift) / 100.0f) * 1.5f` (0.5-2.0Hz)
- Modulation depth: Scaled by dopplerShift magnitude
  - Formula: `modDepth = (std::abs(dopplerShift) / 100.0f) * 0.1f` (0-10% delay variation)
- Delay time modulation:
  - Base delay time from delayTime parameter (tempo-synced or free)
  - LFO output: `lfo = std::sin(phase)` (range -1.0 to +1.0)
  - Modulated delay: `delayTimeModulated = baseDelay * (1.0f + lfo * modDepth)`
  - Applied continuously via DelayLine::setDelay()
- Phase increment: `phaseInc = (lfoFreq * 2π) / sampleRate`
- Phase wrapping: `phase = fmod(phase + phaseInc, 2π)`
- Natural pitch artifacts:
  - Delay time variation creates pitch bending (doppler effect)
  - Simulates tape speed fluctuation (wow and flutter)
  - Complements granular pitch shifter (layered doppler effect)

### Tempo Sync Quantization

**Algorithm:** Snap delay time to nearest musical subdivision based on host BPM

**Implementation notes:**
- Query host BPM: `getPlayHead()->getPosition()->getBpm()`
- Default BPM: 120.0 (if host doesn't provide)
- Clamp BPM: `bpm = juce::jlimit(20.0, 300.0, bpm)` (valid range)
- Note divisions (in beats):
  - 1/16 = 0.25 beats
  - 1/8 = 0.5 beats
  - 1/4 = 1.0 beats
  - 1/2 = 2.0 beats
  - 1 bar = 4.0 beats
  - 2 bars = 8.0 beats
  - 4 bars = 16.0 beats
  - 8 bars = 32.0 beats
- Convert to milliseconds: `ms = (60000.0 / bpm) * beats`
- Quantization:
  - Find nearest note division to delayTime parameter value
  - Calculate distance to each division: `distance = std::abs(delayTimeMs - divisionMs)`
  - Select division with minimum distance
  - Update delay line with quantized time
- Reference: AngelGrain `quantizeDelayTimeToTempo()` function

---

## Integration Points

### Feature Dependencies

- **Delay Line → Pitch Shifter:** Pitch shifter reads from delay line output (delay must process first)
- **Delay Line → Time Stretcher:** Time stretcher reads from delay line output (delay must process first)
- **Delay Time Modulator → Delay Line:** Modulator sets delay line length (modulation must apply before delay read)
- **Parallel Routing → All Components:** Both paths independent (no dependencies between distortion and delay paths)
- **Output Mixer → All Components:** Mixer receives outputs from both paths (processing must complete before mixing)

### Parameter Interactions

- **dopplerShift affects multiple features:**
  - Pitch Shifter: Controls semitone shift (±12 semitones)
  - Time Stretcher: Controls speed change (±50% speed)
  - Delay Modulator: Controls modulation depth (0-10% delay variation)
  - All three create layered doppler effect

- **pitchEnable toggles processing mode:**
  - ON: Pitch shifting + time stretching (full doppler effect)
  - OFF: Time stretching only (speed changes without pitch)
  - Does NOT disable delay time modulation (always active)

- **tempoSync changes delay time interpretation:**
  - ON: delayTime maps to musical subdivisions (1/16 to 8 bars)
  - OFF: delayTime maps to milliseconds (0-16000ms)
  - Switching modes changes effective delay range

- **Level controls are independent:**
  - delayLevel: Scales delay path only
  - distortionLevel: Scales distortion path only
  - masterOutput: Scales final mix (both paths)
  - No cross-talk or interaction between level controls

### Processing Order Requirements

**Sequential processing order (REQUIRED):**

**Delay Path Processing Order:**
1. **Read input:** Store stereo input for delay path processing
2. **Apply delay line:** Process delay with current delay time (tempo-synced or free)
3. **Modulate delay time:** Apply LFO-driven delay time variation (doppler simulation)
4. **Pitch shift (if enabled):** Apply granular pitch shifting to delayed signal
5. **Time stretch (if pitch disabled):** Apply granular time stretching without pitch change
6. **Scale by delayLevel:** Apply delay path volume control

**Distortion Path Processing Order:**
1. **Read input:** Store stereo input for distortion path processing (same input as delay path)
2. **Apply tube saturation:** Tanh waveshaping with saturation gain
3. **Scale by distortionLevel:** Apply distortion path volume control

**Final Mixing:**
1. **Sum both paths:** Add delay path output + distortion path output
2. **Apply master gain:** Scale summed output by masterOutput parameter
3. **Write to output buffer:** Final stereo output

**Why order matters:**
- Delay must process before pitch shifting (pitch shifter reads delay output)
- Delay time modulation must apply before delay read (affects delay length)
- Pitch shift and time stretch are mutually exclusive (pitchEnable toggles mode)
- Level controls apply after DSP processing (avoid clipping intermediate stages)
- Master output is last (final gain staging)

**Parallel processing notes:**
- Delay path and distortion path can run in parallel (no dependencies)
- Input buffer duplicated to both paths at start
- Both paths process independently
- No interaction until final mixing stage

### Thread Boundaries

**Threads:**
- **Audio thread:** All DSP processing in processBlock() - NO allocations, NO locks
- **Message thread:** Parameter updates, preset loading, UI interactions

**Audio thread operations:**
- All DSP processing (delay, pitch shift, time stretch, saturation, mixing)
- Parameter reads via `APVTS::getRawParameterValue()->load()` (atomic)
- Host tempo query via `getPlayHead()` (host-provided, real-time safe)
- Sample-by-sample processing in processBlock()

**Message thread operations:**
- Parameter updates from UI via APVTS (atomic writes)
- Preset loading/saving
- UI repaints

**No background thread needed:**
- No file I/O
- No long-running operations
- All processing is real-time compatible

**Communication:**
- APVTS parameters: Atomic reads (audio thread) / atomic writes (message thread)
- No custom thread communication needed (APVTS handles it)

---

## Implementation Risks

### Granular Pitch Shifting

**Complexity:** HIGH
- Grain buffer management (circular buffer with multiple read pointers)
- Overlap-add synthesis (4 simultaneous grains with windowing)
- Pitch-shifted grain playback (variable-rate resampling)
- Artifact minimization (grain boundary smoothing)

**Risk Level:** HIGH

**Risk factors:**
1. Granular synthesis is algorithmically complex
   - Multiple grain playback engines (4 overlapping grains)
   - Grain windowing and overlap-add math
   - Pitch-shifted playback requires interpolation
2. No existing JUCE granular class (custom implementation required)
3. CPU cost moderate (~20-30% single core for 4-grain overlap)
4. Artifacts possible (graininess, metallic sound if grain size/overlap incorrect)
5. Buffer management complexity (circular grain buffer + overlap tracking)

**Alternative approaches:**
1. **Phase vocoder (FFT-based):**
   - Complexity: VERY HIGH
   - Quality: Higher than granular (cleaner, less graininess)
   - CPU: Higher (~40-60% single core)
   - Latency: Higher (~42ms for 2048 FFT size)
   - Best for: Production-quality pitch shifting (if granular artifacts unacceptable)

2. **Simple delay-based pitch shift:**
   - Complexity: LOW
   - Quality: Lowest (only works for small shifts, obvious artifacts)
   - CPU: Minimal (~5% single core)
   - Latency: Minimal
   - Best for: Prototyping only (not production)

**Fallback architecture:**
- **Primary:** Granular synthesis (4-grain overlap, Hann window)
- **Fallback 1:** Reduce grain overlap to 2x (lower CPU, acceptable quality for creative effect)
- **Fallback 2:** Fixed pitch shift only (no continuous doppler modulation)
- **Fallback 3:** Simple delay-based pitch shift (prototyping, not production release)

**Mitigation strategy:**
1. Implement granular engine in isolation first (unit test pitch shift accuracy)
2. Start with 2-grain overlap (lower CPU), scale to 4-grain if CPU allows
3. Tune grain size (50-100ms range) to minimize artifacts
4. Reference existing granular implementations (JUCE forum examples)
5. Profile CPU usage early (may need quality modes: draft/standard/HQ)

### Tempo Sync Implementation

**Complexity:** MEDIUM
- Host BPM query is straightforward (AngelGrain reference)
- Note division quantization requires mapping logic
- Switching between tempo-sync and free time modes

**Risk Level:** LOW

**Risk factors:**
1. Host may not provide BPM (need fallback to 120 BPM)
2. BPM can change mid-buffer (detection challenging)
3. Switching tempo-sync on/off may cause audible glitch (delay time jump)

**Alternative approaches:**
None needed (tempo sync is standard pattern, well-documented)

**Fallback architecture:**
- **Primary:** Full tempo sync with 8 note divisions (1/16 to 8 bars)
- **Fallback 1:** Reduce to 4 note divisions (1/8, 1/4, 1/2, 1 bar) if UI too complex
- **Fallback 2:** Free time mode only (no tempo sync) if host integration fails

**Mitigation strategy:**
1. Copy AngelGrain tempo sync implementation (proven reference)
2. Test with multiple DAWs (Ableton, Logic, FL Studio)
3. Smooth delay time transitions (ramp over 10ms to avoid clicks)
4. Default to 120 BPM if host doesn't provide tempo

### Parallel Signal Routing

**Complexity:** LOW
- Duplicate input buffer to two paths
- Process each path independently
- Sum outputs with gain scaling

**Risk Level:** LOW

**Risk factors:**
1. Buffer duplication may cause memory issues (negligible, ~10KB per buffer)
2. Ensure both paths don't write to same buffer (buffer management)

**Alternative approaches:**
None needed (parallel routing is standard, well-documented)

**Fallback architecture:**
- **Primary:** True parallel routing (independent paths)
- **Fallback:** Serial routing (delay → distortion) if parallel proves problematic

**Mitigation strategy:**
1. Use separate AudioBuffer for each path (clear ownership)
2. Test with extreme parameter settings (ensure no buffer overflow)
3. Reference FlutterVerb dry/wet mixer (similar parallel architecture)

### Overall Project Risk

**Overall complexity:** HIGH
- Granular pitch shifting (HIGH) + tempo sync (MEDIUM) + parallel routing (LOW)
- Highest risk: Granular pitch shifter (70% of project risk)

**Highest risk component:** Granular Pitch Shifter
- Most algorithmically complex (grain management, overlap-add, windowing)
- No JUCE class (custom implementation)
- Artifact risk (graininess if tuned incorrectly)
- CPU cost moderate but significant

**Recommended approach:**
1. **Phase 1 - Validate concept:** Implement parallel routing + basic delay + tube saturation (LOW risk)
2. **Phase 2 - Build foundation:** Add tempo sync + delay time modulation (MEDIUM risk)
3. **Phase 3 - Core implementation:** Implement granular pitch shifter (HIGH risk)
4. **Phase 4 - Fallback testing:** If granular artifacts unacceptable, reduce overlap or grain size
5. **Phase 5 - Polish:** Optimize CPU, tune grain parameters, reduce artifacts

---

## Architecture Decisions

### Granular Synthesis for Pitch Shifting

**Decision:** Use granular synthesis (not phase vocoder) for pitch shifting

**Rationale:**
- Lower complexity than phase vocoder (FFT-based)
- Lower CPU cost (~20-30% vs ~40-60% for phase vocoder)
- Lower latency (~10-20ms vs ~42ms for phase vocoder)
- Acceptable quality for creative doppler effect (not transparent pitch correction)
- JUCE has DelayLine support (useful for granular implementation)
- Professional plugins use granular for creative pitch effects (phase vocoder for transparent shifting)

**Alternatives considered:**
1. **Phase vocoder (FFT-based):**
   - Why rejected: Higher complexity, higher CPU, higher latency, overkill for doppler effect
   - When to reconsider: If granular artifacts unacceptable (upgrade to phase vocoder for v2.0)

2. **Delay-based pitch shift:**
   - Why rejected: Poor quality (obvious artifacts), not professional-grade
   - When to reconsider: Prototyping only (not production)

**Tradeoffs accepted:**
- **Granular artifacts:** May have slight graininess compared to phase vocoder
  - Acceptable because: Doppler effect is creative, not transparent (artifacts add character)
- **Fixed pitch range:** ±1 octave (±12 semitones) vs unlimited range with phase vocoder
  - Acceptable because: Red shift concept is ±1 octave (50% = -1 octave, -50% = +1 octave)
- **Grain size constraints:** Large grains (50-100ms) to minimize artifacts
  - Acceptable because: Delay effect already adds latency (grain latency is negligible)

**When to revisit:**
- If granular artifacts reported as unacceptable by users (upgrade to phase vocoder)
- If CPU usage exceeds 50% single core (optimize grain overlap or size)
- If pitch range needs extension beyond ±1 octave (phase vocoder supports wider range)

### Parallel Signal Architecture

**Decision:** True parallel routing (delay and distortion paths independent) with separate level controls

**Rationale:**
- Professional parallel processing standard (FabFilter, Waves CLA Epic)
- Mix engineers expect independent path control (delay vs distortion balance)
- Creative flexibility (100% delay + 100% distortion possible)
- Simpler implementation than serial routing (no interdependencies)

**Alternatives considered:**
1. **Serial routing (delay → distortion or distortion → delay):**
   - Why rejected: Less flexible (one path affects other), harder to balance levels
   - When to reconsider: If true parallel proves too CPU-intensive (unlikely)

2. **Single wet/dry mix control:**
   - Why rejected: Doesn't allow independent delay/distortion balance (less creative control)
   - When to reconsider: If UI becomes too complex (simplify mixer section)

**Tradeoffs accepted:**
- **Higher CPU usage:** Processing two independent paths vs one path
  - Acceptable because: CPU cost is moderate (delay + granular + saturation = ~40% single core)
- **More complex UI:** Three level controls (delay, distortion, master) vs one mix knob
  - Acceptable because: Professional mixing flexibility outweighs UI complexity

**When to revisit:**
- If users report UI confusion (add preset-based guidance or simplify to two controls)
- If CPU usage excessive (merge paths into serial routing)

### Tempo Sync with Musical Subdivisions

**Decision:** Full tempo sync support with 8 note divisions (1/16 to 8 bars) + free time mode

**Rationale:**
- Professional delay plugins offer tempo sync (Valhalla Delay, FabFilter Timeless)
- Studio workflow standard (lock effects to song tempo)
- AngelGrain reference implementation (proven pattern)
- Host BPM query is simple and real-time safe

**Alternatives considered:**
1. **Free time mode only (no tempo sync):**
   - Why rejected: Less professional, reduces plugin value for studio use
   - When to reconsider: If host integration fails (unlikely, standard feature)

2. **Reduced subdivision set (4 divisions instead of 8):**
   - Why rejected: Limits creative options (no 1/16 notes or 8-bar delays)
   - When to reconsider: If UI becomes too complex

**Tradeoffs accepted:**
- **Host dependency:** Requires host to provide BPM (fallback to 120 BPM if unavailable)
  - Acceptable because: All modern DAWs provide BPM, fallback is robust
- **UI complexity:** Toggle switch + extended range for tempo vs free time
  - Acceptable because: Standard UX pattern in delay plugins

**When to revisit:**
- If tempo sync unreliable across DAWs (test thoroughly in Stage 4)
- If users rarely use tempo sync (consider removing for v2.0 if unused)

---

## Special Considerations

### Thread Safety
- All parameter reads use atomic `getRawParameterValue()->load()` (real-time safe)
- Granular grain buffers are pre-allocated in prepareToPlay (no allocations in audio thread)
- Delay line buffers sized for maximum delay (20 seconds at 192kHz)
- No shared state between channels (per-channel grain tracking)
- Host tempo query via getPlayHead() is host-provided and real-time safe

### Performance
- **Granular pitch shifter:** ~20-30% CPU (most expensive component)
  - 4-grain overlap with 100ms grain size at 48kHz
  - Variable-rate grain playback (interpolation)
- **Delay line:** ~5% CPU (Lagrange3rd interpolation)
- **Tube saturation:** ~3% CPU (per-sample tanh)
- **Delay time modulator:** ~2% CPU (sine LFO calculation)
- **Total estimated:** ~40% single core at 48kHz
- **Optimization opportunities:**
  - Reduce grain overlap to 2x (trade quality for CPU)
  - Use linear interpolation instead of Lagrange3rd (trade smoothness for CPU)
  - Apply saturation only if saturation parameter > -12dB (bypass threshold)

### Denormal Protection
- Use `juce::ScopedNoDenormals` in processBlock()
- All JUCE DSP components handle denormals internally
- Grain LFO phase wrapping prevents denormals (explicit wrapping at 2π)
- Delay line interpolation handles denormals (JUCE DelayLine internals)

### Sample Rate Handling
- Delay line buffer sized for maximum delay at 192kHz (3,840,000 samples)
- Granular engine grain size scales with sample rate (100ms * sampleRate)
- LFO phase increment scales with sample rate: `phaseInc = (freq * 2π) / sampleRate`
- Tempo sync milliseconds calculated per-buffer (BPM can change)
- All processing reinitialized in prepareToPlay() on sample rate change

### Latency
- Granular pitch shifter: ~10-20ms (grain size + overlap delay)
- Delay line: User-controlled (0-16000ms, not counted as latency)
- Tube saturation: 0ms (instantaneous waveshaping)
- Total plugin latency: ~10-20ms (report via getLatencySamples() for host compensation)
- Note: Delay time is NOT latency (user-controlled effect parameter)

---

## Research References

### Professional Plugins

1. **Strymon Deco (Tape Saturator & Doubletracker)**
   - Tape saturation with adjustable lag time (sub-millisecond to full echo)
   - Wobble control adds random modulation (wow and flutter)
   - Studied vintage tape machine characteristics
   - Observed: Tape speed modulation creates natural pitch artifacts

2. **Strymon TimeLine (Multi-Delay)**
   - dTape machine mode with full control over Tape Age, Wow & Flutter, Tape Crinkle
   - Three distinct tape machine modes (clean, aged, worn)
   - Observed: Professional doppler implementation via tape speed variation

3. **FabFilter Timeless 3 (Delay)**
   - Time-stretching mode keeps same pitch when changing delay time
   - Stretch mode allows changing delay time without pitch change
   - Observed: Independent time/pitch manipulation for doppler effects

4. **Waves Abbey Road Saturator**
   - Modeled after two legendary Beatles-era consoles at Abbey Road Studios
   - Second-order harmonics (tube warmth) and third-order harmonics (tape punch)
   - Observed: Saturation range typically -12dB to +24dB for musical material

5. **UAD Brainworx bx_saturator V2**
   - Multi-band M/S saturation processor
   - Adjustable drive and saturation curves
   - Observed: Parallel saturation architecture for mixing flexibility

### JUCE Documentation

- **juce::dsp::DelayLine<float, Lagrange3rd>**: Variable delay with Lagrange3rd interpolation
  - Lagrange3rd provides smooth interpolation for pitch modulation (low artifacts)
  - setDelay() allows real-time delay time changes (doppler simulation)
  - Maximum delay buffer configurable via setMaximumDelayInSamples()

- **juce::AudioPlayHead::getPosition()**: Get host playback position info
  - PositionInfo::getBpm() extracts BPM from host
  - Returns optional<double> (may be unavailable, need fallback)

- **juce::dsp::ProcessSpec**: DSP component configuration
  - sampleRate, maximumBlockSize, numChannels
  - Used by all juce::dsp components in prepare() calls

- **juce::AudioProcessorValueTreeState**: Parameter management
  - Automatic serialization/deserialization (XML via ValueTree)
  - Atomic parameter access (getRawParameterValue()->load())

### Technical Resources

- **Granular Synthesis Literature:**
  - "Real-Time Granular Synthesis with Texture Control" (Curtis Roads)
  - Grain size: 50-100ms typical for pitch shifting (minimizes graininess)
  - Overlap factor: 4x (75% overlap) for smooth output
  - Window function: Hann window (smooth attack/release, no clicks)

- **Tempo Sync Implementation:**
  - AngelGrain reference implementation (lines 170-190, PluginProcessor.cpp)
  - Formula: `ms = (60000 / bpm) * beats`
  - Note divisions: 0.25 (1/16), 0.5 (1/8), 1.0 (1/4), 2.0 (1/2), 4.0 (1 bar), etc.

- **Parallel Processing:**
  - Baby Audio blog: "Parallel Processing: How Blending Wet and Dry Can Improve Your Mix"
  - Industry standard for reverb, delay, compression (New York compression)
  - Two common architectures: Internal dry/wet mix OR aux send/return (we use internal)

- **Doppler Effect Simulation:**
  - Tape flutter characteristics: 0.5-2.0Hz LFO, 5-10% delay time variation
  - Strymon Deco wobble control: Random modulation (our version uses sine LFO for predictability)

---

## Notes

- Granular pitch shifter is highest complexity component (70% of project risk)
- Tempo sync implementation proven (AngelGrain reference)
- Parallel routing is straightforward (low risk)
- Tube saturation is simple (tanh waveshaping, well-documented)
- Total estimated CPU: ~40% single core at 48kHz (acceptable for studio use)
- Latency: ~10-20ms (granular grain size, report for host compensation)
- No file I/O, no multi-output routing, no MIDI (stereo audio effect only)
- All state is parameter-based (APVTS automatic serialization, no custom state)
