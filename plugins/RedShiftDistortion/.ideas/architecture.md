# DSP Architecture: RedShiftDistortion

**CRITICAL CONTRACT:** This specification is immutable during Stages 1-4 implementation. Stage 1 Planning cannot proceed without this file. Stage 3 (DSP) implements this exact architecture.

**Generated by:** Stage 0 Research (2026-02-10)
**Referenced by:** Stage 1 (Planning), Stage 3 (DSP Implementation)
**Purpose:** DSP specification defining processing components, signal flow, and JUCE module usage

---

## Core Components

### Stereo Width Modulation

- **JUCE Class:** Custom implementation using `juce::dsp::DelayLine<float, juce::dsp::DelayLineInterpolationTypes::Linear>`
- **Purpose:** Create spatial positioning via differential L/R delay times (±260ms max)
- **Parameters Affected:** `stereoWidth` (-100% to +100%)
- **Configuration:**
  - Stereo width at 0%: L and R delay times are equal (mono output)
  - Stereo width at +100%: R channel delayed by +260ms relative to L (wide stereo)
  - Stereo width at -100%: L channel delayed by +260ms relative to R (inverted wide stereo)
  - Formula: `delayDifferential = (stereoWidth / 100.0) * 260.0 ms`
  - L channel delay: `baseDelay + (stereoWidth < 0 ? abs(delayDifferential) : 0)`
  - R channel delay: `baseDelay + (stereoWidth > 0 ? delayDifferential : 0)`
  - Linear interpolation (no artifacts for static delay times)
  - Independent of doppler shift (spatial vs frequency separation)

### Tape Delay with Feedback Loop

- **JUCE Class:** `juce::dsp::DelayLine<float, juce::dsp::DelayLineInterpolationTypes::Linear>`
- **Purpose:** Core delay line with feedback loop containing cumulative effects
- **Parameters Affected:** `feedback` (0-95%)
- **Configuration:**
  - Base delay time: Fixed at 260ms (matches stereo width max differential)
  - Feedback gain: 0.0 to 0.95 (scaled from 0-95% parameter)
  - Feedback path contains: Granular Doppler → Saturation → Dual-Band Filters (in order)
  - Cumulative processing: Each repeat applies doppler shift + saturation again
  - Stability: Limited to 95% max feedback to prevent runaway oscillation
  - Buffer size: 260ms at 192kHz = 49,920 samples max

### Granular Doppler Shift

- **JUCE Class:** Custom implementation using `juce::dsp::DelayLine` + grain windowing
- **Purpose:** Pitch shift each delay repeat cumulatively (±12 semitones per repeat)
- **Parameters Affected:** `dopplerShift` (-50% to +50%), `grainSize` (25-200ms), `grainOverlap` (2x or 4x)
- **Configuration:**
  - **Pitch shift range:** -50% = -12 semitones, +50% = +12 semitones
  - **Pitch shift formula:** `pitchRatio = pow(2.0, (dopplerShift / 100.0) * 12.0 / 12.0)` = `pow(2.0, dopplerShift / 100.0)`
  - **Grain buffer:** Two DelayLines (L + R) sized for max grain size (200ms at 192kHz = 38,400 samples)
  - **Grain overlap:** 2x = 2 simultaneous grains, 4x = 4 simultaneous grains
  - **Windowing function:** Hann window for smooth grain boundaries
    - Formula: `w(n) = 0.5 * (1 - cos(2π * n / N))`
  - **Grain playback speed:** Read pointer advances at `pitchRatio` speed
    - Upshift (+50%): Read pointer moves faster (2x speed = +1 octave)
    - Downshift (-50%): Read pointer moves slower (0.5x speed = -1 octave)
  - **Crossfade:** Overlapping grains crossfade using Hann window
  - **Output:** Sum of all active grains (2 or 4 depending on overlap setting)
  - **CUMULATIVE:** Each feedback repeat applies another pitch shift
    - Example: +50% shift, 5 repeats = original + 1oct + 2oct + 3oct + 4oct + 5oct

### Cumulative Saturation

- **JUCE Class:** `juce::dsp::WaveShaper<float>` with `std::tanh` function
- **Purpose:** Apply tube saturation to each repeat (cumulative warmth buildup)
- **Parameters Affected:** `saturation` (-12dB to +24dB)
- **Configuration:**
  - Transfer function: `output = std::tanh(gain * input)`
  - Gain calculation: `gain = pow(10.0, saturationDB / 20.0)`
    - -12dB → 0.251x gain (clean, slight warmth)
    - 0dB → 1.0x gain (unity, moderate saturation)
    - +24dB → 15.85x gain (heavy saturation, harmonics)
  - Applied INSIDE feedback loop, AFTER granular doppler shift
  - Creates cumulative effect: Each repeat saturates more than previous
  - Example: +12dB saturation, 5 repeats = progressively more saturated harmonics
  - No oversampling (granular processing already band-limits high frequencies)

### Dual-Band Filtering (Feedback Loop)

- **JUCE Class:** `juce::dsp::IIR::Filter<float>` (two filters: hi-pass + lo-pass)
- **Purpose:** Shape frequency content in feedback path (simulate tape frequency response)
- **Parameters Affected:** `filterBandLow` (20-20000 Hz), `filterBandHigh` (20-20000 Hz)
- **Configuration:**
  - **Hi-pass filter (lo-cut):**
    - Cutoff: `filterBandLow` parameter (20-20000 Hz)
    - Default: 100 Hz (removes sub-bass rumble)
    - Filter type: 2nd-order Butterworth (12 dB/oct)
    - Coefficients: `juce::dsp::IIR::Coefficients<float>::makeHighPass(sampleRate, cutoff, Q=0.707)`
  - **Lo-pass filter (hi-cut):**
    - Cutoff: `filterBandHigh` parameter (20-20000 Hz)
    - Default: 8000 Hz (removes digital harshness)
    - Filter type: 2nd-order Butterworth (12 dB/oct)
    - Coefficients: `juce::dsp::IIR::Coefficients<float>::makeLowPass(sampleRate, cutoff, Q=0.707)`
  - Both filters applied in series INSIDE feedback loop
  - Applied AFTER saturation (filters saturated signal)
  - Creates progressive darkening with each repeat (classic tape delay behavior)

### Master Output Level

- **JUCE Class:** Simple gain multiplication (no JUCE class needed)
- **Purpose:** Final output level control after all processing
- **Parameters Affected:** `masterOutput` (-60dB to +12dB)
- **Configuration:**
  - Gain calculation: `gain = pow(10.0, masterOutputDB / 20.0)`
    - -60dB → 0.001x gain (near silence)
    - 0dB → 1.0x gain (unity)
    - +12dB → 3.98x gain (boost)
  - Applied after dry/wet mix (if we add dry/wet in future)
  - Per-sample multiplication in processBlock

### Bypass Controls

- **JUCE Class:** Conditional routing (no JUCE class needed)
- **Purpose:** Allow bypassing individual processing stages for troubleshooting
- **Parameters Affected:** `bypassStereoWidth`, `bypassDelay`, `bypassDoppler`, `bypassSaturation`
- **Configuration:**
  - **bypassStereoWidth:** If true, set stereoWidth to 0.0 (mono output)
  - **bypassDelay:** If true, skip entire delay + feedback loop (dry signal only)
  - **bypassDoppler:** If true, skip granular pitch shifting (keeps delay + saturation)
  - **bypassSaturation:** If true, skip saturation stage (keeps delay + doppler)
  - Bypass checks happen in processBlock before each stage
  - Zero-latency bypass (no smoothing needed for debug/troubleshooting use)

---

## Processing Chain

```
Input (Stereo)
  ↓
[Bypass Check: bypassDelay?]
  ├─ YES → Skip to Master Output
  └─ NO → Continue
      ↓
Stereo Width Modulation ← stereoWidth parameter, bypassStereoWidth
  ├─ L channel: baseDelay + (stereoWidth < 0 ? differential : 0)
  └─ R channel: baseDelay + (stereoWidth > 0 ? differential : 0)
  ↓
Tape Delay (260ms base) + Feedback Loop ← feedback parameter
  ↓
  ┌─────────────────────────── Feedback Loop ──────────────────────────┐
  │                                                                     │
  │  [Bypass Check: bypassDoppler?]                                    │
  │    ├─ YES → Skip granular processing                               │
  │    └─ NO → Granular Doppler Shift ← dopplerShift, grainSize, grainOverlap
  │              (CUMULATIVE: ±12 semitones per repeat)                │
  │                                                                     │
  │  [Bypass Check: bypassSaturation?]                                 │
  │    ├─ YES → Skip saturation                                        │
  │    └─ NO → Tube Saturation ← saturation parameter                  │
  │              (CUMULATIVE: each repeat saturates more)              │
  │                                                                     │
  │  Dual-Band Filtering ← filterBandLow, filterBandHigh               │
  │    ├─ Hi-Pass Filter (lo-cut)                                      │
  │    └─ Lo-Pass Filter (hi-cut)                                      │
  │                                                                     │
  │  Feedback Gain ← feedback parameter (0.0-0.95)                     │
  │    └─ Mix with current input (feedback * previousOutput)           │
  │                                                                     │
  └─────────────────────────────────────────────────────────────────────┘
  ↓
Master Output Level ← masterOutput parameter (-60dB to +12dB)
  ↓
Output (Stereo)
```

**Routing notes:**
- Series chain: Each stage processes output of previous stage
- Feedback loop: Output of filters feeds back into delay input (cumulative effects)
- Bypass controls: Conditional routing for each major stage
- No parallel paths: Pure series processing for simplicity
- No dry/wet mix: Effect is 100% wet (cumulative delay design)

---

## System Architecture

### State Persistence

**What state is saved:**
- APVTS parameters: All 13 parameters (automatic via AudioProcessorValueTreeState)
  - 7 main controls: stereoWidth, feedback, filterBandLow, filterBandHigh, dopplerShift, saturation, masterOutput
  - 4 bypass controls: bypassStereoWidth, bypassDelay, bypassDoppler, bypassSaturation
  - 2 advanced settings: grainSize, grainOverlap
- No custom state needed (all state is APVTS parameters)

**Serialization format:**
- APVTS parameters: Automatic XML via ValueTree (JUCE built-in)
- No custom serialization needed

**JUCE classes:**
- `juce::AudioProcessorValueTreeState` - Automatic parameter persistence

**Restore behavior:**
- All parameters restored from XML automatically
- No validation needed (APVTS clamps values to valid ranges)
- No folder paths or file references (no custom state)

---

## Parameter Mapping

| Parameter ID | Type | Range | DSP Component | Usage |
|-------------|------|-------|---------------|-------|
| stereoWidth | Float | -100.0 to 100.0 % | Stereo Width Modulation | L/R delay differential (±260ms) |
| feedback | Float | 0.0 to 95.0 % | Tape Delay Feedback Loop | Feedback gain (0.0-0.95) |
| filterBandLow | Float | 20.0 to 20000.0 Hz | Dual-Band Filtering (Hi-Pass) | Hi-pass cutoff in feedback loop |
| filterBandHigh | Float | 20.0 to 20000.0 Hz | Dual-Band Filtering (Lo-Pass) | Lo-pass cutoff in feedback loop |
| dopplerShift | Float | -50.0 to 50.0 % | Granular Doppler Shift | Pitch shift per repeat (±12 semitones) |
| saturation | Float | -12.0 to 24.0 dB | Cumulative Saturation | Tube saturation drive (0.25x-15.85x gain) |
| masterOutput | Float | -60.0 to 12.0 dB | Master Output Level | Final output level |
| bypassStereoWidth | Bool | Off/On | Bypass Controls | Bypass stereo width (mono output) |
| bypassDelay | Bool | Off/On | Bypass Controls | Bypass entire delay + feedback loop |
| bypassDoppler | Bool | Off/On | Bypass Controls | Bypass granular pitch shifting |
| bypassSaturation | Bool | Off/On | Bypass Controls | Bypass tube saturation |
| grainSize | Float | 25.0 to 200.0 ms | Granular Doppler Shift | Grain buffer size (quality vs CPU) |
| grainOverlap | Choice | 0=2x, 1=4x | Granular Doppler Shift | Simultaneous grain count (2x or 4x) |

---

## Algorithm Details

### Stereo Width Algorithm

**Algorithm:** Differential L/R delay times for spatial positioning

**Implementation notes:**
- Base delay: 260ms (fixed, matches max differential)
- Delay differential: `(stereoWidth / 100.0) * 260.0 ms`
- L channel delay time: `260ms + (stereoWidth < 0 ? abs(differential) : 0)`
- R channel delay time: `260ms + (stereoWidth > 0 ? differential : 0)`
- At stereoWidth = 0%: Both channels delayed by 260ms (mono, no spatial effect)
- At stereoWidth = +100%: R delayed by +260ms relative to L (wide stereo)
- At stereoWidth = -100%: L delayed by +260ms relative to R (inverted wide)
- Use Linear interpolation (DelayLine with Linear type)
- No smoothing needed (stereo width typically static parameter)

### Granular Doppler Shift Algorithm

**Algorithm:** Grain-based pitch shifting with overlapping windowed grains

**Implementation notes:**
- **Pitch ratio calculation:** `pitchRatio = pow(2.0, dopplerShift / 100.0)`
  - -50% → pitchRatio = 0.5 (down 1 octave)
  - 0% → pitchRatio = 1.0 (no shift)
  - +50% → pitchRatio = 2.0 (up 1 octave)
- **Grain scheduling:**
  - Grain duration: `grainSize` parameter (25-200ms)
  - Overlap count: `grainOverlap` parameter (2x or 4x simultaneous grains)
  - Grain spacing: `grainSize / overlapCount`
    - 2x overlap: Grains start every `grainSize / 2` samples
    - 4x overlap: Grains start every `grainSize / 4` samples
- **Grain playback:**
  - Write pointer: Advances at sample rate (writes incoming audio to circular buffer)
  - Read pointers: Advance at `pitchRatio * sampleRate` (faster = upshift, slower = downshift)
  - Each grain has independent read pointer starting at write pointer - grainSize
  - Linear interpolation for fractional sample positions
- **Hann window formula:**
  - `w(n) = 0.5 * (1.0 - cos(2.0 * π * n / grainSize))`
  - Applied to each grain sample during read
  - Smooth envelope (0 at start/end, 1 at center)
- **Output mixing:**
  - Sum all active grain outputs: `output = Σ(grain[i] * window[i])`
  - With 2x overlap: 2 grains active, with 4x overlap: 4 grains active
  - Overlapping windows naturally crossfade (Hann windows sum to constant amplitude)
- **Buffer management:**
  - Circular buffer sized for max grain size: 200ms at 192kHz = 38,400 samples
  - Separate buffers for L and R channels
  - Grain read pointers wrap around at buffer end

### Tape Saturation Algorithm

**Algorithm:** Hyperbolic tangent waveshaping

**Implementation notes:**
- Transfer function: `output = std::tanh(gain * input)`
- Gain curve: `gain = pow(10.0, saturationDB / 20.0)`
  - -12dB → 0.251x (subtle warmth)
  - 0dB → 1.0x (moderate saturation)
  - +12dB → 3.98x (strong saturation)
  - +24dB → 15.85x (extreme saturation, heavy harmonics)
- Applied per-sample in processBlock loop
- No oversampling (granular processing already band-limits)
- CUMULATIVE in feedback loop: Each repeat saturates more
  - Repeat 1: `tanh(gain * input)`
  - Repeat 2: `tanh(gain * tanh(gain * input))` (progressively more clipped)

### Dual-Band Filtering Algorithm

**Algorithm:** Series 2nd-order Butterworth hi-pass + lo-pass filters

**Implementation notes:**
- **Hi-pass filter (lo-cut):**
  - Cutoff: `filterBandLow` parameter (20-20000 Hz)
  - Q factor: 0.707 (Butterworth, maximally flat passband)
  - Coefficients: `IIR::Coefficients<float>::makeHighPass(sampleRate, cutoff, 0.707)`
  - Update: Recalculate coefficients when parameter changes (in processBlock)
- **Lo-pass filter (hi-cut):**
  - Cutoff: `filterBandHigh` parameter (20-20000 Hz)
  - Q factor: 0.707 (Butterworth)
  - Coefficients: `IIR::Coefficients<float>::makeLowPass(sampleRate, cutoff, 0.707)`
  - Update: Recalculate coefficients when parameter changes
- **Series configuration:** Hi-pass → Lo-pass
- **Bandpass result:** Only frequencies between filterBandLow and filterBandHigh pass through
- **Edge case:** If filterBandLow > filterBandHigh, swap values (ensure valid bandpass range)
- Applied INSIDE feedback loop (cumulative filtering effect)

---

## Integration Points

### Feature Dependencies

- Stereo Width → Tape Delay: Stereo-widened signal feeds into delay input
- Tape Delay → Granular Doppler: Delayed signal feeds into granular processing
- Granular Doppler → Saturation: Pitch-shifted signal feeds into saturation
- Saturation → Dual-Band Filters: Saturated signal feeds into filters
- Dual-Band Filters → Feedback Mixer: Filtered signal mixes back into delay input
- All features → Processing order: Sequential dependencies require strict order

### Parameter Interactions

- **stereoWidth affects spatial positioning (independent of dopplerShift):**
  - Stereo width creates L/R delay differential
  - Doppler shift creates pitch movement
  - No interaction (conceptually distinct effects)

- **dopplerShift amplifies with feedback:**
  - Higher feedback → More repeats → More cumulative pitch shift
  - Example: +50% doppler, 90% feedback = ~10 repeats = pitch rises 10 octaves
  - Mitigation: High doppler + high feedback naturally shifts out of audible range (self-limiting)

- **saturation amplifies with feedback:**
  - Higher feedback → More repeats → More cumulative saturation
  - Each repeat saturates more than previous (progressive harmonic buildup)
  - Mitigation: tanh is bounded (-1 to +1), prevents runaway clipping

- **filterBandLow and filterBandHigh define bandpass range:**
  - Only frequencies between lo-cut and hi-cut pass through feedback
  - Narrow band (e.g., 500Hz-1000Hz) creates resonant feedback
  - Wide band (e.g., 100Hz-8000Hz) creates natural tape delay sound
  - Edge case: If lo-cut > hi-cut, swap values to ensure valid range

- **grainSize vs grainOverlap tradeoff:**
  - Larger grainSize: Smoother sound, more latency, less CPU per grain
  - Higher grainOverlap: Smoother sound, more CPU (more simultaneous grains)
  - Recommended: grainSize=100ms, grainOverlap=4x (best quality)
  - Low CPU mode: grainSize=50ms, grainOverlap=2x (acceptable quality)

### Processing Order Requirements

**Sequential processing order (REQUIRED):**

1. **Stereo Width Modulation:** Apply L/R delay differential first
   - Must happen before delay to create spatial positioning
   - Static positioning (not modulated by LFO)

2. **Write to Delay Buffer:** Store stereo-widened signal in delay line
   - Base delay: 260ms (fixed)
   - Circular buffer write pointer advances at sample rate

3. **Read from Delay Buffer:** Read delayed signal from 260ms ago
   - Delay line output is input to feedback loop

4. **[FEEDBACK LOOP START] Granular Doppler Shift:** Apply pitch shift to delayed signal
   - If bypassDoppler: Skip this stage
   - Otherwise: Process through granular pitch shifter
   - CUMULATIVE: Each repeat applies another pitch shift

5. **Tube Saturation:** Apply saturation to pitch-shifted signal
   - If bypassSaturation: Skip this stage
   - Otherwise: Apply tanh waveshaping
   - CUMULATIVE: Each repeat saturates more

6. **Dual-Band Filtering:** Filter saturated signal
   - Hi-pass filter (lo-cut) removes low frequencies
   - Lo-pass filter (hi-cut) removes high frequencies
   - Series configuration: Hi-pass → Lo-pass

7. **Feedback Gain:** Scale filtered signal for feedback loop
   - Multiply by feedback parameter (0.0-0.95)
   - Controls feedback intensity

8. **Mix with Current Input:** Add feedback signal to current delay input
   - `delayInput = currentInput + (feedback * filteredOutput)`
   - Closes feedback loop (step 7 output → step 2 input of next cycle)

9. **[FEEDBACK LOOP END] Master Output Level:** Scale final output
   - Apply master output gain (-60dB to +12dB)
   - Final output is mix of dry + all feedback repeats

**Why order matters:**
- Stereo width before delay: Creates spatial positioning of repeats
- Doppler before saturation: Saturates pitch-shifted signal (more natural harmonics)
- Saturation before filters: Filters shape saturated harmonics (classic tape behavior)
- Filters before feedback: Prevents feedback buildup of extreme frequencies
- Feedback loop closure: Step 8 output feeds step 2 input of next cycle (cumulative effects)

### Thread Boundaries

**Audio thread:**
- All DSP processing (stereo width, delay, granular, saturation, filters)
- Parameter reads via `APVTS::getRawParameterValue()->load()` (atomic)
- Sample-by-sample processing in processBlock()
- Grain scheduling and windowing calculations
- Filter coefficient updates (when parameters change)

**Message thread:**
- Parameter updates from UI via APVTS (atomic writes)
- Preset loading/saving
- UI repaints
- Bypass button clicks

**No background thread needed:**
- No file I/O
- No long-running operations
- All processing is real-time compatible

**Communication:**
- APVTS parameters: Atomic reads (audio thread) / atomic writes (message thread)
- No custom thread communication needed (APVTS handles it)

**Safety guarantees:**
- Audio thread NEVER allocates memory (all buffers pre-allocated in prepareToPlay)
- Audio thread NEVER waits on locks
- Parameter changes are atomic (no race conditions)
- Filter coefficient updates happen in audio thread (no shared state)

---

## Implementation Risks

### Granular Doppler Shift

**Complexity:** HIGH
- Requires grain scheduling, overlapping windowed reads, pitch ratio calculations
- Multiple simultaneous read pointers (2 or 4 grains)
- Hann window calculation and application per sample
- Buffer management for circular grain buffer

**Risk Level:** HIGH

**Risk factors:**
1. Granular synthesis is algorithmically complex (not as complex as phase vocoder, but still non-trivial)
   - Grain scheduling logic (when to start new grains)
   - Read pointer management (fractional sample positions, wraparound)
   - Window function application (per-sample multiplication)
2. No existing JUCE granular pitch shifter class (custom implementation required)
3. Moderate CPU cost (~30-40% single core for 4x overlap)
4. Latency (grain size = 100ms default, ~4800 samples @ 48kHz)
5. Artifacts if implemented incorrectly:
   - Clicks/pops at grain boundaries (if window not smooth)
   - Pitch instability (if read pointer not accurate)
   - Amplitude modulation (if overlap not constant)

**Alternative approaches:**
1. **Phase vocoder (FFT-based):**
   - Complexity: HIGHER (requires FFT → phase adjustment → IFFT)
   - Quality: Higher than granular (cleaner, less grainy)
   - CPU: Higher (~50-60% single core)
   - Latency: Higher (~40-50ms for 2048 FFT)
   - Best for: Maximum quality (professional shimmer reverbs)
   - Reject reason: Higher complexity, higher CPU, diminishing returns for cumulative doppler effect

2. **Delay-based pitch shift (varispeed):**
   - Complexity: LOW (simple delay time modulation)
   - Quality: Lowest (only works for small shifts, audible artifacts)
   - CPU: Very low (~5% single core)
   - Latency: Minimal (~1-2ms)
   - Best for: Prototyping only (not production quality)
   - Reject reason: Poor quality for ±12 semitone shifts

**Fallback architecture:**
- **Primary:** Granular synthesis (medium complexity, good quality, moderate CPU)
- **Fallback 1:** If granular artifacts unacceptable → Phase vocoder (higher quality, higher CPU)
- **Fallback 2:** If granular fails completely → Delay-based pitch shift (prototype quality)
- **Fallback 3:** If all pitch shifting fails → Remove doppler, keep delay + saturation (reduced scope)

**Mitigation strategy:**
1. Start with simple 2x overlap, increase to 4x if artifacts present
2. Use Hann window (well-documented, smooth envelope)
3. Test with sine wave input first (verify pitch accuracy before musical material)
4. Benchmark CPU usage early (may need quality vs. performance modes)
5. Reference open-source granular implementations (PaulStretch, ChowDSP)
6. Implement grain scheduler in isolation, test before integration

### Cumulative Feedback Loop Stability

**Complexity:** MEDIUM
- Feedback loop contains 3 processing stages (doppler, saturation, filters)
- Cumulative effects can cause runaway oscillation if not limited
- Parameter interactions (high feedback + high doppler = pitch shifts out of range)

**Risk Level:** MEDIUM

**Risk factors:**
1. Feedback gain >95% can cause runaway oscillation with high saturation
2. High doppler shift + high feedback = rapid pitch escalation (could cause buffer overflows)
3. Filter resonance (if Q > 0.707) could amplify feedback
4. Saturation is cumulative (could build up DC offset over many repeats)

**Alternative approaches:**
1. **Soft-clipping feedback gain:**
   - Apply tanh to feedback gain to soft-limit above 90%
   - Prevents hard cutoff at 95%
   - Smoother transition to self-oscillation

2. **Dynamic feedback limiting:**
   - Reduce feedback gain based on output level
   - If output > -6dBFS, scale feedback down
   - Prevents runaway oscillation automatically

**Fallback architecture:**
- **Primary:** Fixed 95% max feedback with hard limit
- **Fallback 1:** If oscillation occurs → Add soft-clipping above 90%
- **Fallback 2:** If still unstable → Add dynamic feedback limiting based on output level
- **Fallback 3:** If all fails → Reduce max feedback to 80%

**Mitigation strategy:**
1. Test feedback at extreme settings (95% feedback + max saturation + max doppler)
2. Monitor output level in debug builds (assert if output > 1.0)
3. Add DC blocker after saturation (remove DC offset buildup)
4. Use Butterworth filters (Q=0.707) to avoid resonance
5. Test with long audio files (10+ seconds) to verify stability over time

### Dual-Band Filter Parameter Inversion

**Complexity:** LOW
- Simple filter configuration, well-documented JUCE classes

**Risk Level:** LOW

**Risk factors:**
1. User could set filterBandLow > filterBandHigh (invalid bandpass range)
2. Cutoff frequency at Nyquist limit (sampleRate / 2) could cause instability

**Alternative approaches:**
1. **Clamp hi-cut to be above lo-cut:**
   - If filterBandLow > filterBandHigh, set filterBandHigh = filterBandLow + 100Hz
   - Ensures valid bandpass range
   - May confuse user (hi-cut jumps when lo-cut adjusted)

2. **Swap values if inverted:**
   - If filterBandLow > filterBandHigh, swap them
   - Ensures valid bandpass range
   - More intuitive (filters always work as expected)

**Fallback architecture:**
- **Primary:** Swap values if lo-cut > hi-cut (simple, intuitive)
- **Fallback 1:** If swapping causes UI confusion → Add parameter dependency (hi-cut min = lo-cut + 100Hz)
- **Fallback 2:** If all fails → Use StateVariableFilter instead of IIR::Filter (less prone to instability)

**Mitigation strategy:**
1. Check for inverted values in processBlock before creating filter coefficients
2. Clamp cutoff frequencies to 20Hz-20kHz range (avoid Nyquist issues)
3. Use Butterworth Q=0.707 (maximally flat, no resonance)
4. Test with extreme settings (lo-cut=20kHz, hi-cut=20Hz) to verify swap logic
5. Add UI validation (disable hi-cut < lo-cut in parameter attachment)

### Overall Project Risk

**Overall complexity:** HIGH
- Granular pitch shifting (HIGH) + cumulative feedback (MEDIUM) + dual-band filters (LOW)
- 3 complex features with interdependencies
- Estimated CPU: 37-57% single core (high but acceptable for creative effect)

**Highest risk component:** Granular Doppler Shift
- Represents ~70% of project risk
- Most algorithmically complex component
- No JUCE class (custom implementation required)
- Highest CPU cost and artifact risk

**Recommended approach:**
1. **Phase 1 - Foundation:** Implement stereo width + basic delay (no feedback) - LOW risk
2. **Phase 2 - Feedback loop:** Add saturation + filters + feedback (no doppler yet) - MEDIUM risk
3. **Phase 3 - Granular doppler:** Implement granular pitch shifting in feedback loop - HIGH risk
4. **Phase 4 - Fallback testing:** If granular artifacts unacceptable, consider phase vocoder - HIGH risk
5. **Phase 5 - Polish:** Optimize CPU, tune parameters, reduce artifacts, test stability

---

## Architecture Decisions

### Granular Synthesis vs Phase Vocoder for Pitch Shifting

**Decision:** Use granular synthesis for doppler pitch shifting

**Rationale:**
- Moderate complexity (lower than phase vocoder, higher than delay-based)
- Acceptable quality for cumulative doppler effect (graininess adds to "tape" character)
- Lower CPU than phase vocoder (~30-40% vs ~50-60%)
- Lower latency than phase vocoder (~100ms vs ~40-50ms for FFT)
- JUCE has DelayLine primitives (no FFT pipeline needed)
- Professional plugins use granular for creative pitch effects (FabFilter Timeless)

**Alternatives considered:**
1. **Phase vocoder (FFT-based):**
   - Why rejected: Higher complexity (FFT → phase unwrapping → IFFT), higher CPU, overkill for cumulative effect
   - When to reconsider: If granular artifacts prove unacceptable in testing

2. **Delay-based pitch shift:**
   - Why rejected: Poor quality (only works for small shifts), not professional-grade
   - When to reconsider: For initial prototype only (not production)

**Tradeoffs accepted:**
- **Graininess artifacts:** Granular synthesis has inherent graininess vs phase vocoder's cleaner output
  - Acceptable because: "Tape" aesthetic tolerates graininess, cumulative effect masks artifacts, doppler is creative effect not transparent processing
- **Moderate CPU usage:** 30-40% single core vs 5% for delay-based
  - Acceptable because: Target is studio use (not real-time performance), quality is priority, CPU is within acceptable range
- **100ms latency:** Grain size default is 100ms
  - Acceptable because: Delay already adds 260ms latency, doppler is post-processing effect not tracking, total latency reported to host for compensation

**When to revisit:**
- If CPU usage exceeds 60% single core (implement 2x overlap mode, reduce grain size)
- If graininess artifacts are unacceptable (consider phase vocoder fallback)
- If implementation proves too complex (simplify to delay-based prototype)

### Cumulative Effects in Feedback Loop

**Decision:** Place doppler shift AND saturation INSIDE feedback loop (cumulative)

**Rationale:**
- Creates true "red shift" / "blue shift" effect (pitch consistently rises or falls with each repeat)
- Cumulative saturation mimics tape feedback behavior (RE-201 Space Echo, Echoplex)
- Matches creative brief: "cumulative granular doppler shift" and "progressive saturation buildup"
- More interesting than single-pass effects (escalating pitch/harmonic buildup)

**Alternatives considered:**
1. **Doppler outside feedback loop (single-pass):**
   - Why rejected: Loses "red shift" concept (all repeats have same pitch), not cumulative
   - When to reconsider: If cumulative doppler causes instability or CPU issues

2. **Saturation outside feedback loop (single-pass):**
   - Why rejected: Loses cumulative tape warmth (all repeats equally saturated), less authentic
   - When to reconsider: If cumulative saturation causes DC offset buildup or instability

**Tradeoffs accepted:**
- **Potential instability:** Cumulative effects could cause runaway oscillation
  - Mitigation: Limit feedback to 95%, tanh saturation is bounded, test extensively
- **Higher CPU per repeat:** Each repeat processes through doppler + saturation
  - Acceptable because: Feedback typically 3-5 repeats (not hundreds), CPU is moderate
- **Less predictable behavior:** Cumulative effects harder to predict than single-pass
  - Acceptable because: Unpredictability is part of creative appeal, matches "astronomical" theme

**When to revisit:**
- If feedback oscillation occurs at high settings (reduce max feedback or add soft-clipping)
- If CPU usage too high (move saturation outside feedback loop)
- If cumulative doppler shifts too far out of audible range (add pitch limiting)

### Separated Stereo Width and Doppler Shift

**Decision:** Implement stereo width as L/R delay differential (independent of doppler shift)

**Rationale:**
- Stereo width = spatial positioning (left/right separation)
- Doppler shift = frequency movement (pitch rising/falling)
- Conceptually distinct effects (spatial vs frequency)
- Matches creative brief: "separated stereo width modulation and cumulative granular doppler shift"
- Professional plugins separate spatial and frequency effects (FabFilter Timeless, Soundtoys EchoBoy)

**Alternatives considered:**
1. **Stereo width via doppler shift (pitch differential L/R):**
   - Why rejected: Confuses spatial and frequency effects, less intuitive, harder to control
   - When to reconsider: Never (conceptually wrong approach)

2. **Stereo width via panning (no delay):**
   - Why rejected: Doesn't create "depth" effect (just L/R balance), less interesting
   - When to reconsider: If delay-based stereo width causes phase issues (unlikely)

**Tradeoffs accepted:**
- **Additional latency:** Stereo width adds up to 260ms L/R differential
  - Acceptable because: Delay effect already has latency, stereo width is spatial effect (not tracking)
- **Mono compatibility:** Wide stereo (±100%) may phase cancel in mono
  - Acceptable because: Target is stereo use, creative effect (not broadcast), user can reduce width for mono compatibility

**When to revisit:**
- If phase cancellation in mono is problematic (add mono compatibility mode)
- If stereo width feels too subtle (increase max differential to ±500ms)

### No Dry/Wet Mix Parameter

**Decision:** Effect is 100% wet (no dry/wet mix control)

**Rationale:**
- Cumulative delay design means "dry" is first repeat (not original input)
- Feedback parameter already controls wet amount (0% = single repeat, 95% = many repeats)
- Simplifies parameter set (13 parameters already complex)
- Matches creative brief: Series tape delay (not parallel dry/wet blender)

**Alternatives considered:**
1. **Add dry/wet mix parameter:**
   - Why rejected: Adds complexity, feedback already controls wet amount, not needed for cumulative design
   - When to reconsider: If users request ability to blend original signal (post-release feature)

**Tradeoffs accepted:**
- **Cannot blend dry signal:** Effect is always 100% wet
  - Acceptable because: Feedback at 0% is effectively "dry" (single pass), series design is intentional
- **Less flexible than parallel dry/wet:**
  - Acceptable because: Cumulative design requires series processing, user can mix dry in DAW

**When to revisit:**
- If users consistently request dry/wet mix (add as post-release feature)
- If "dry" signal is needed for testing (add bypass controls instead - already implemented)

---

## Special Considerations

### Thread Safety

- All parameter reads use atomic `getRawParameterValue()->load()` in audio thread
- Filter coefficient updates happen in audio thread when parameters change (no allocations, just coefficient recalculation)
- Grain scheduling state is per-channel (no shared state between L and R)
- Delay line buffers pre-allocated in prepareToPlay (no allocations in processBlock)
- Bypass checks are boolean atomics (thread-safe reads)

### Performance

- **Granular doppler:** ~30-40% CPU (most expensive component, depends on overlap setting)
  - 2x overlap: ~20-30% CPU
  - 4x overlap: ~30-40% CPU
- **Saturation:** ~5% CPU (tanh is fast)
- **Dual-band filters:** ~5-10% CPU (two 2nd-order IIR filters)
- **Stereo width + delay:** ~5% CPU (simple delay line reads)
- **Total estimated:** 37-57% single core at 48kHz (high but acceptable for creative effect)
- **Optimization opportunities:**
  - Use SIMD for tanh approximation (faster than std::tanh)
  - Reduce grain overlap to 2x for lower CPU mode (user setting)
  - Reduce grain size to 50ms for lower latency mode (user setting)

### Denormal Protection

- Use `juce::ScopedNoDenormals` in processBlock() (JUCE utility sets FTZ/DAZ flags)
- All JUCE DSP components (DelayLine, IIR::Filter, WaveShaper) handle denormals internally
- Granular grain windowing uses Hann window (never reaches true zero, avoids denormals)
- Feedback loop uses addition (not multiplication by zero), less prone to denormals

### Sample Rate Handling

- Delay line buffers sized for maximum sample rate (192kHz):
  - Stereo width delay: 260ms at 192kHz = 49,920 samples per channel
  - Granular grain buffer: 200ms at 192kHz = 38,400 samples per channel
- Filter coefficients recalculated on sample rate change in prepareToPlay()
- Grain scheduling adjusted for sample rate (grain size in samples = grainSize_ms * sampleRate / 1000)
- All timing parameters scaled by sample rate (no hardcoded sample counts)

### Latency

- **Stereo width delay:** 260ms base delay (12,480 samples at 48kHz)
- **Granular grain size:** Default 100ms (4,800 samples at 48kHz)
- **Total processing latency:** ~260ms + 100ms = 360ms (17,280 samples at 48kHz)
- **Report via `getLatencySamples()`:** Return total latency for host compensation
- **Host compensation:** DAW automatically compensates for reported latency (aligns with other tracks)

---

## Research References

### Professional Plugins

1. **FabFilter Timeless 3**
   - Stereo width via L/R delay differential (Delay Time Pan ring up to 400%)
   - Tape delay with saturation and filtering
   - Modulation engine for creative effects
   - Observed: Wide stereo image without phase issues, intuitive stereo width control

2. **Soundtoys EchoBoy**
   - 31 delay types including tape emulation
   - "Radical Tape Emulation" algorithm for warmth and saturation
   - Dedicated saturation for delayed signals
   - Observed: Cumulative saturation in feedback loop creates tape character

3. **Arturia Delay TAPE-201 (RE-201 emulation)**
   - Three tape heads with spring reverb
   - Feedback (Intensity) overloads circuit for runaway echoes
   - Tape saturation mild distortion
   - Observed: High feedback creates self-oscillation, signature tape delay sound

4. **UAD Galaxy Tape Echo / EP-34 Echoplex**
   - Lively distortion and temporal fluctuations
   - Frequency response and non-linearity per tape type
   - Cumulative tape warmth with each repeat
   - Observed: Each repeat slightly different due to tape variations

### JUCE Documentation

- **juce::dsp::DelayLine:** Variable delay with Linear, Lagrange3rd, Thiran interpolation types
  - Linear interpolation for stereo width (static delay times, no artifacts)
  - Used for granular grain buffer (circular buffer with multiple read pointers)
- **juce::dsp::WaveShaper:** Waveshaping with custom transfer function
  - std::tanh for tape saturation (bounded, smooth, classic tape sound)
- **juce::dsp::IIR::Filter:** Biquad filter with coefficient helpers
  - makeHighPass() and makeLowPass() for dual-band filtering
  - Butterworth Q=0.707 for flat passband (no resonance)

### Technical Resources

- **DSP Labs - Granular Synthesis Implementation:**
  - Grain scheduling: Extract grains with pitch shift factor P, stretch window to P*N
  - Overlap approach: Overlapping grains sum to constant amplitude (Hann windows)
  - Windowing: Blackman-Harris for smooth overlap, Hann for simplicity
  - Pitch shift: Read pointer speed = pitchRatio * sampleRate
- **Granular Synthesis (Sound on Sound):**
  - Grain duration: 1-50ms typical (we use 25-200ms for quality)
  - Overlap percentage: Controls smoothness (2x = rougher, 4x = smoother)
  - Grain cloud: Up to 1000 grains possible (we use 2-4 for CPU efficiency)
- **JUCE Forum - Granular Synthesis:**
  - Interpolation for fractional samples: Linear interpolation sufficient for granular
  - Combine previous grain with current at overlapping samples
  - Write to output buffer: Sum of all active grains

---

## Notes

- Granular doppler shift is the highest risk component (~70% of project risk)
- Cumulative feedback behavior requires extensive stability testing
- Estimated CPU: 37-57% single core (high but acceptable for creative effect)
- Latency: ~360ms total (260ms delay + 100ms grain size) - must report to host
- Bypass controls allow troubleshooting individual stages (not typical for production use)
- Advanced settings (grain size, grain overlap) exposed for quality/CPU tradeoff tuning
- No dry/wet mix (100% wet series design) - feedback parameter controls wet amount
- Phase-based implementation recommended (3 phases for DSP: foundation, feedback loop, granular doppler)
