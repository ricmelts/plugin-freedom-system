# DSP Architecture: LushVerb

**CRITICAL CONTRACT:** This specification is immutable during Stages 2-5 implementation. Stage 1 Planning cannot proceed without this file. Stage 4 (DSP) implements this exact architecture.

**Generated by:** Stage 0 Research (2025-11-11)
**Referenced by:** Stage 1 (Planning), Stage 4 (DSP Implementation)
**Purpose:** DSP specification defining processing components, signal flow, and JUCE module usage

---

## Core Components

### Reverb Engine (Core)
- **JUCE Class:** `juce::dsp::Reverb`
- **Purpose:** Generate lush algorithmic reverb with controllable size and damping
- **Parameters Affected:** SIZE, DAMPING
- **Configuration:**
  - SIZE (0.5-20s) maps to combined roomSize and decay characteristics
    - Formula: roomSize = 0.3 + (sizeSeconds / 20.0) * 0.7 (range 0.3-1.0)
    - Longer times require feedback adjustments to maintain decay
  - DAMPING (0-100%) maps directly to damping parameter (0.0-1.0)
    - Formula: damping = dampingPercent / 100.0
    - 0% = bright/crystalline, 100% = dark/warm
  - Width fixed at 1.0 (full stereo)
  - freezeMode disabled (no infinite hold)
  - Wet/dry levels managed externally by DryWetMixer

### Shimmer Pitch Shifter
- **JUCE Class:** Custom implementation using phase vocoder technique
- **Purpose:** Generate +1 octave pitch-shifted signal for ethereal shimmer effect
- **Parameters Affected:** SHIMMER
- **Configuration:**
  - Pitch shift: +12 semitones (exactly +1 octave)
  - SHIMMER (0-100%) controls mix amount of shifted signal
    - 0% = shimmer disabled (bypass)
    - 30% = default subtle ethereal layer
    - 100% = maximum shimmer presence
  - Implementation approach: Phase vocoder (preferred over granular for quality)
    - FFT size: 2048 samples (balance between quality and latency)
    - Hop size: 512 samples (4x overlap)
    - Window: Hann window for smooth grain transitions
  - Shimmer signal feeds into reverb input (pre-reverb routing)
  - Alternative if phase vocoder too complex: juce::dsp::DelayLine with pitch modulation

### Built-in Modulation System
- **JUCE Class:** Custom LFO using `std::sin()` phase accumulation
- **Purpose:** Add subtle chorus-like depth and movement to reverb tail
- **Parameters Affected:** None (always-on, not user-controllable)
- **Configuration:**
  - Dual LFO system for stereo width:
    - LFO 1: 0.3 Hz (slow, left channel bias)
    - LFO 2: 0.5 Hz (slightly faster, right channel bias)
  - Modulation depth: ±3% pitch variation (very subtle)
  - Applied via delay line modulation within reverb tail
  - Implementation: Small delay buffer (50ms) with LFO-controlled read position
  - Interpolation: Lagrange 3rd-order for smooth pitch modulation

### Dry/Wet Mixer
- **JUCE Class:** `juce::dsp::DryWetMixer<float>`
- **Purpose:** Blend dry (input) and wet (processed) signals
- **Parameters Affected:** MIX
- **Configuration:**
  - MIX (0-100%) maps to wet proportion (0.0-1.0)
    - Formula: wetMix = mixPercent / 100.0
    - 0% = fully dry (bypass)
    - 100% = fully wet (reverb only)
  - Automatically handles latency compensation
  - Maintains constant power blending

---

## Processing Chain

```
Input (Stereo)
  ↓
Dry/Wet Mixer (capture dry) ← MIX parameter
  ↓
┌─────────────────────────────┐
│ Wet Signal Processing       │
│                             │
│  Input + Shimmer Mix        │
│    ↓                        │
│  Shimmer Pitch Shifter      │ ← SHIMMER parameter (amount)
│    (+1 octave)              │
│    ↓                        │
│  Combined Signal            │
│    (dry input + shimmer)    │
│    ↓                        │
│  Reverb Engine              │ ← SIZE, DAMPING parameters
│    (with built-in           │
│     modulation)             │
│    ↓                        │
│  Reverb Output              │
└─────────────────────────────┘
  ↓
Dry/Wet Mixer (blend) ← MIX parameter
  ↓
Output (Stereo)
```

**Routing notes:**
- Shimmer pitch shifter operates pre-reverb (shifted signal feeds reverb input)
- Shimmer bypass when SHIMMER = 0% (no processing overhead)
- Built-in modulation always active on reverb tail (non-bypassable)
- Dry signal bypasses all processing and goes directly to mixer
- All processing maintains stereo throughout

---

## Parameter Mapping

| Parameter ID | Type | Range | DSP Component | Usage |
|-------------|------|-------|---------------|-------|
| SIZE | Float | 0.5-20.0s | Reverb Engine | Maps to roomSize (0.3-1.0) + feedback adjustments for long tails |
| DAMPING | Float | 0-100% | Reverb Engine | Maps to damping parameter (0.0-1.0, linear) |
| SHIMMER | Float | 0-100% | Shimmer Pitch Shifter | Mix amount of +1 octave signal (0.0-1.0) |
| MIX | Float | 0-100% | Dry/Wet Mixer | Wet proportion (0.0-1.0, linear) |

---

## Algorithm Details

### Reverb Engine (juce::dsp::Reverb)

**Algorithm:** Freeverb-based algorithm with comb filters and allpass filters

**Implementation notes:**
- SIZE parameter requires dual mapping:
  - roomSize: `0.3 + (sizeSeconds / 20.0) * 0.7`
  - Feedback adjustment for longer tails: custom scaling beyond 5s
- DAMPING maps linearly: `damping = dampingPercent / 100.0`
- Width always 1.0 for maximum stereo spread
- No freeze mode (normal reverb decay only)
- Call `reverb.setParameters()` in audio thread when parameters change
- No sample-rate-dependent tuning needed (JUCE handles internally)

### Shimmer Pitch Shifter

**Algorithm:** Phase vocoder for high-quality pitch shifting

**Implementation notes:**
- FFT-based pitch shifting with phase locking
- Window function: Hann window for grain smoothness
  - `window[i] = 0.5 * (1.0 - cos(2π * i / windowSize))`
- Pitch shift ratio: 2.0 (exactly +1 octave)
- Overlap-add synthesis for grain reconstruction
- SHIMMER parameter controls output gain of shifted signal:
  - `shimmerGain = shimmerPercent / 100.0`
  - Multiply shifted output by shimmerGain before mixing with input
- Bypass optimization: Skip FFT processing when SHIMMER = 0%
- Latency: ~50ms (2048 samples at 44.1kHz) - report via getLatencySamples()

**Alternative implementation (if phase vocoder too complex):**
- Use `juce::dsp::DelayLine<float>` with variable read position
- Pitch shift via playback rate (read position increment = 2.0 for +1 octave)
- Crossfade between grains to avoid clicks
- Lower quality but simpler to implement

### Built-in Modulation System

**Algorithm:** Dual LFO delay line modulation

**Implementation notes:**
- LFO phase accumulation: `phase += (frequency * 2π) / sampleRate`
- Phase wrap: `if (phase >= 2π) phase -= 2π`
- Modulation output: `modAmount = sin(phase) * depthPercent * 0.01`
- Apply to delay line read position within reverb tail
- Depth: ±3% (0.03 in normalized terms)
- Two LFO instances for stereo:
  - Left: 0.3 Hz base frequency
  - Right: 0.5 Hz base frequency
- Per-sample processing in audio thread
- No parameter control (hardcoded values)

### Dry/Wet Mixer

**Algorithm:** Constant power blending with latency compensation

**Implementation notes:**
- Use `juce::dsp::DryWetMixer<float>` for automatic latency handling
- Call `pushDrySamples()` before processing wet signal
- Call `mixWetSamples()` after wet processing complete
- Set wet mix ratio: `dryWetMixer.setWetMixProportion(mixPercent / 100.0)`
- Update in audio thread when MIX parameter changes
- No manual latency compensation needed (handled by JUCE)

---

## Special Considerations

### Thread Safety
- All parameter reads use `parameters.getRawParameterValue(id)->load()` (atomic)
- Reverb parameters updated via `setParameters()` in audio thread (no mutex needed)
- Phase vocoder state is per-instance (no shared state between channels)
- LFO phase state is per-channel (left/right independent)
- DryWetMixer handles internal synchronization

### Performance
- Reverb engine: ~25-30% CPU (JUCE's Reverb is optimized)
- Shimmer phase vocoder: ~15-20% CPU (FFT processing)
- Built-in modulation: ~5% CPU (simple sine calculations)
- Dry/wet mixing: ~2% CPU (buffer operations)
- **Total estimated: ~50-60% single core at 48kHz**
- Optimization: Bypass shimmer FFT when SHIMMER = 0%

### Denormal Protection
- Use `juce::ScopedNoDenormals` in `processBlock()`
- juce::dsp::Reverb handles denormals internally
- Phase vocoder: Add DC offset (1e-10) to avoid denormals in FFT bins
- LFO phase wrapping prevents accumulation errors

### Sample Rate Handling
- Reverb reinitialized in `prepareToPlay()` with new sample rate
- Phase vocoder buffers resized based on sample rate (2048 samples constant)
- LFO phase increment recalculated: `phaseIncrement = (frequency * 2π) / sampleRate`
- Delay line for modulation sized for 50ms at max expected rate (192kHz = 9600 samples)
- All components call `prepare()` in `prepareToPlay()`

### Latency
- Shimmer phase vocoder: ~50ms (2048 samples at 44.1kHz)
- Reverb: ~10-20ms internal buffering
- DryWetMixer compensates automatically
- **Total latency: ~60-70ms**
- Report via `getLatencySamples()` for host compensation:
  - `return static_cast<int>(sampleRate * 0.06);` (60ms)

---

## Research References

### Professional Plugins

1. **Strymon BigSky**
   - Industry-leading algorithmic reverb with shimmer mode
   - Shimmer: Two independent pitch shifters (+1 octave typical)
   - Pitch shifters regenerate with reverb (feedback loop)
   - Size range: Small rooms to infinite spaces
   - Parameter range: Decay times extend to 20+ seconds
   - Observation: Shimmer feeds reverb input (pre-reverb routing)

2. **Valhalla Shimmer**
   - Dedicated shimmer reverb plugin
   - Classic shimmer: +12 semitones (octave up) with feedback ≥0.5
   - Diffusion control: 0.9 for reverberant sounds, <0.5 for echo-like
   - Size parameter affects delay line lengths (larger = longer decay)
   - Observation: Feedback and diffusion are key to lush character

3. **Valhalla VintageVerb**
   - Smooth, musical reverb with comprehensive damping control
   - Cathedral mode for large spaces (Size >50% = real cathedral scale)
   - Damping section provides smooth high-frequency decay
   - Observation: Damping is critical for bright/dark tail character

4. **Eventide Blackhole**
   - Known for infinite tail capability
   - Massive reverb sizes (up to 30+ seconds)
   - Observation: Feedback control essential for infinite sustain

### JUCE Documentation

- **juce::dsp::Reverb**: Freeverb-based algorithm with Parameters struct
  - roomSize: 0.0-1.0 (small to big room)
  - damping: 0.0-1.0 (no damping to fully damped)
  - width: 0.0-1.0 (narrow to wide stereo)
  - Freeze mode available but not used in this design
  - Call `setParameters()` to update (not thread-safe, use in audio thread)

- **juce::dsp::DryWetMixer**: Latency-compensated mixing
  - Automatically delays dry signal to match wet processing latency
  - Use `pushDrySamples()` before processing, `mixWetSamples()` after

- **juce::dsp::DelayLine**: Variable delay with interpolation types
  - Lagrange3rd recommended for pitch modulation (smooth, low artifacts)

### Technical Resources

- **CCRMA Stanford Paper: "Shimmer Audio Effect - A Harmonic Reverberator"**
  - Phase vocoder technique combined with FDN reverberator
  - Pitch shift +1 and +2 octaves before sending to reverb
  - Demonstrates pre-reverb routing approach

- **Phase Vocoder Tutorial (CMU)**
  - Time stretching without pitch change (inverse for pitch shifting)
  - FFT size 2048 recommended for musical signals
  - Hann window for smooth grain transitions
  - Phase locking prevents frequency smearing

- **Freeverb Algorithm**
  - Open-source reference for understanding juce::Reverb parameters
  - Comb filters + allpass filters = smooth decay
  - roomSize controls feedback gain of comb filters

---

## Notes

- **Shimmer routing:** Pitch-shifted signal feeds reverb input (not parallel). This creates the classic "shimmering tail" effect where the octave-up signal itself reverberates.
- **Modulation approach:** Built-in modulation is subtle and always-on (per creative brief). No user control keeps interface simple.
- **SIZE parameter challenge:** Extending beyond typical reverb decay (0.5-5s) to 20s requires feedback adjustments. May need custom scaling formula for SIZE > 10s.
- **Phase vocoder vs granular:** Phase vocoder chosen for cleaner pitch shifting (less artifacts). Fallback to delay-based granular if implementation time too long.
- **Performance target:** 50-60% CPU is acceptable for a lush, high-quality reverb. Target optimization: shimmer bypass when unused.
- **Latency acceptable:** 60-70ms latency is typical for reverb effects (not a dealbreaker for mixing/creative use).
